## 물리적 데이터베이스 설계

### 물리적 데이터베이스 설계란
- 논리적 설계의 데이터 구조를 보조 기억 장치상의 화일(물리적인 데이터 모델)로 사상
- 예상 빈도를 포함하여 데이터베이스 질의와 트랜잭션을 분석, 조인 연산의 속도 향상, 가장 빈번하게 사용되는 애트리뷰트에 대한 중점 두기 등을 하는 단계
- 물리적 데이터베이스 설계는 특정 DBMS의 특성을 고려하여 진행된다. 
- 질의를 효율적으로 지원하기 위해 인덱스 구조를 활용
- DBMS가 [ANSI/SPARC](https://vvshinevv.tistory.com/36) 모델을 잘 따른다면 논리적인 데이터베이스 설계가 물리적인 데이터베이스 설계로 사상되기 쉽다. 
- DBMS는 운영 체제와 상호 작용을 하면서 디스크로부터 데이터를 읽어온다. 이때 운영체제의 구성요소들 중에서 화일 시스템이 DBMS와 상호 작용한다. 

### 보조 기억 장치
- 사용자가 필요 하는 데이터를 검색하려면 DBMS는 디스크상의 데이터베이스로 부터 사용자가 원하는 데이터를 포함하는 블럭을 읽어서 주기억 장치로 가져와야한다. 그리고 변경사항을 다시 디스크레 기록해야한다. 

- 블록
  - 주기억 장치에서 페이지
  - 각 화일은 고정된 크기의 블록들로 나누어져서 저장된다. 

- 디스크
  - 데이터베이스를 장기간 보관하는 주된 보조 기억 장치.
  - 직접 접근 장치로 디스크 상의 임의의 위치에 있는 데이터를 바로 접근할 수 있다.
  - 자기 물질로 만들어진 여러 개의 판으로 이루어진다.
    - 트랙: 디스크 표면상의 동심원
    - 실린더: 디스크의 여러개의 디스크면중에서 같은 지름을 갖는 트랙들을 실린더라고 부른다
    - 섹터: 한 트랙을 나눈 단위
    - 블록: 한 개 이상의 섹터로 이루어진다 
  - 탐구 시간: 원하는 실린더 위에 디스크 헤드가 놓일때까지 걸리는 시간
  - 회전 지연 시간: 원하는 블록이 디스크 헤드 밑에 올때까지 걸리는 시간(평균 0.5 회전시간)
  - 전송 시간: 블록을 주기억 장치로 전송하는데 걸리는 시간(블록 크기와 버스 속도에 따라 달라짐)
  - <strong>_디스크 장치의 속도에 비해 중앙 처리 장치의 속도가 매우 빠르기때문에 디스크와 주기억 장치 간의 데이터 전송이 데이터베이스 응용에서 주요 병목이 된다_</strong>:
    - DBMS의 성능은 주로 디스크 입출력 연산의 횟수에 좌우된다. 

- 자기테이프
  - 주로 데이터베이스를 백업하기 위해서 사용한다
  - 순차 접근만 가능하기때문에 디스크 장치보다 속도가 느리다
  - 각 판은 트랙과 섹터로 구분된다


### 버퍼 관리와 운영체제
- 디스크(보조기억장치) 입출력은 컴퓨터 시스템에서 가장 속도가 느린 작업이므로 입출력 횟수를 줄이는 것이 DBMS 성능을 향상시키는데 매우 중요하다. 
- 가능한 많은 블록을 주기억 장치에 유지하거나, 자주 참조되는 블록을 주기억 장치에 유지함으로써 전송시간을 줄일 수 있다(블록 전송 횟수 감소). 
- LRU(Least Recently Used / 가장 오래전에 참조된 블록)알고리즘:
  - 버퍼가 꽉찾을때 가장 오래전에 참조된 블록을 디스크로 내보내고 그 자리에 지금 필요한 블록을 읽어온다
  - 이를 통해 최근에 접근된 블록을 유지하여, 어떤 블록에 대한 요청은 디스크 접근이 필요없도록 한다. 
  - 항상 좋은 성능을 보이는 것은 아니다

### 디스크상에서 화일의 레코드 배치
- 채우기 인수(fill factor): 각 블록에 레코드를 채우는 공간의 비율
- 화일 내의 클러스터링: 한 화일내에서 함께 검색될 가능성이 높은 레코드들을 디스크상에서 물리적으로 가까운 곳에 모아두는 것
- 화일 간의 클러스터링: 논리적으로 연관되어서 함께 검색될 가능성이 높은 두 개 이상의 화일에 속한 레코드들을 디스크상에서 물리적으로 가까운 곳에 저장하는 것


### 화일 조직
화일 내의 데이터를 보조 기억 장치에서 블록과 레코드들로 배치하는 것

히프 화일, 순차 화일, 인덱스된 순차 화일 등이 있다. 

(블로킹 인수 (Bf) : 한 블록에 포함시킬 수 있는 논리적 레코드 수)

- 히프 화일(비순서 화일)
  - 가장 단순한 화일 조직
  - 레코드들이 삽입된 순서대로 저장되므로, 원하는 레코드를 찾기 위해서 모든 레코드들을 순차적으로 접근 해야한다. 
  - 새로 삽입되는 레코드는 화일의 가장 끝에 첨부되므로, 삽입은 쉽고 레코드들의 순서가 없다.
  - 삭제는 원하는 레코드를 찾은 후 삭제하고, 차지하던 공간은 재사용하지 않는다. 
  - 데이터를 한꺼번에 적재(bulk loading)하고 주로 검색 위주로 사용될때 히프 화일이 주로 사용된다. 
  - <strong>질의에서 모든 레코드들을 참조하고 레코드들을 접근하는순서는 중요하지 않을때 효율적이다</strong>
  - <strong>특정 레코드를 검색하는 경우에는 히프 화일이 비효율적이다(원하는 블록을 찾기 위해 평균적으로 0.5전체블록을 읽어야하기 때문)</strong>

- 순차 화일
  - 레코드들이 하나 이상의 필드 값에 따라 순서대로 저장된 화일
  - _탐색키_
    - 탐색값의 순서에 따라 저장된다
    - 탐색키는 순차 화일을 정렬하는 데 사용되는 필드이다
  - 삽입과 삭제 시에 레코드 순서를 고려해야해서 시간이 오래걸리기때문에, 기본인덱스가 순차 화일에 정의되지 않는한 데이터베이스 응용을 위해서 거의 사용되지 않음
  - 탐색키를 기반으로 탐색하는 경우에는 효율적이지만, 탐색키가 아닌 경우는 히프화일처럼 전체 탐색을 해야함

- 인덱스된 순차 화일
  - 인덱스를 통해서 임의의 레코드를 접근할 수 있는 화일이다. 
  - 인덱스는 데이터 화일과는 별도의 화일에 저장 된다.
  - 데이터 화일에 들어있는 여러 애트리뷰트들 중에서 탐색키에 해당하는 일부 애트리뷰트만 인덱스에 포함되기 때문에 인덱스의 크기는 보통 데이터 화일크기의 10~20% 크기이다. 
  - 하나의 화일에 대해 여러개의 인덱스들을 정의할 수 있다. 
  - 인덱스가 데이터 화일보다 크기가 작으므로 인덱스가 순차적으로 찾는시간은 데이터 화일을 순차적으로 탐색하는 시간보다 적게 걸린다
  - _탐색키_
    - 인덱스가 정의된 필드
    - 반드시 고유하지 않아도 된다

### 인덱스 종류
- 기본 인덱스: 탐색 키가 데이터 화일의 기본 키인 인덱스(희소인덱스로 구성가능)


- 클러스터링 인덱스
  - 탐색키값에 따라 정렬된 데이터 화일에 대해 정의
  - 각 데이터 블록 대신에 각각의 상이한 키 값마다 하나의 인덱스 엔트리가 인덱스에 포함되어, 그 탐색키 값을 갖는 첫번째 레코드의 주소를 가리킴


- 보조 인덱스: 
  - 탐색키 값에 따라 정렬되지 않은 데이터 화일에 대해 정의
  - 보조 인덱스는 주로 밀집 인덱스로 구성됨
  - 예를들어 신용카드 회아세어 신용카드번호에 대해 기본인덱스를 생성한다. 하지만 주민번호를 통해서 고객의 레코드를 찾아야 하는 경우, 모든 레코드를 읽어야하는데 실사용이 어렵다. 이때 주민번호를 통해서 보조인덱스를 생성해뒀으면 접근이 쉬워진다. 
  

- 희소 인덱스:
  - 일부 키 값에 대해서만 인덱스에 엔트리를 유지하는 것
  - 각 블록마다 한개의 탐색 키 값이 인텍스 엔트리에 포함
  - 각 데이터 블록마다 한개의 엔트리를 갖는다


- 다단계 인덱스:
  - 인덱스가 큰 경우 인덱스를 탐색하는 시간도 오래 걸릴 수 있다.
  - 이때, 단인 단계 인덱스를 디스크 상의 하나의 순서 화일로 간주하고, 이에 대해 인덱스를 정의할 수 있다. 
  - 1단계 인덱스(원래의 인덱스)는 희소/밀집 모두 가능하지만 2단계 이상의 인덱스는 희소 인덱스만 가능하다. 
  - 다단계 인덱스는 가장 상위 단계의 모든 인덱스엔트리가 한블록에 들어갈 수 있을때까지 반복하고, 이 최 상위 단계 인덱스를 마스터 인덱스라고 부른다. 이는 항상 주기억 장치에 상주가 가능하다
  - 주로 B+- 트리를 사용한다. 

- 인덱스는 검색 속도를 향상 시키지만, 삽입, 삭제, 수정 연산의 속도를 저하시킨다. 가능한 릴레이션당 인덱스 수를 3개 이내로 유지해야한다













### 참고자료
[데이터베이스 배움터(oracle)](http://www.yes24.com/Product/Goods/4154340)
[블로그자료](https://m.blog.naver.com/PostView.nhn?blogId=thooy&logNo=10084642491&proxyReferer=https:%2F%2Fwww.google.com%2F)